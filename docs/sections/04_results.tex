\section{Hasil dan Pembahasan}
\label{sec:results}

Bagian ini memaparkan analisis mendalam mengenai kinerja algoritma ASCON-128 dibandingkan dengan AES-128-GCM. Evaluasi dilakukan tidak hanya pada satu skenario, melainkan mencakup berbagai ukuran payload yang merepresentasikan variasi perintah pada sistem IoT kunci sepeda pintar. Metrik yang dianalisis meliputi latensi waktu komputasi, penggunaan memori (RAM), throughput, serta model biaya komputasi untuk ekstrapolasi perangkat keras.

\subsection{Analisis Latensi (Waktu Eksekusi)}
Latensi diukur sebagai waktu total yang dibutuhkan untuk melakukan operasi enkripsi dan autentikasi lengkap. Gambar \ref{fig:latency} mengilustrasikan perbandingan latensi kedua algoritma pada payload 64 byte.

\begin{itemize}
    \item \textbf{ASCON-128}: Rata-rata waktu enkripsi tercatat sebesar 350.75 $\mu$s. Kurva distribusi menunjukkan variansi yang rendah ($\sigma < 120 \mu$s), menandakan stabilitas kinerja algoritma.
    \item \textbf{AES-128-GCM}: Mencapai rata-rata waktu enkripsi 38.47 $\mu$s. Kecepatan ini sangat tinggi, hampir 9 kali lebih cepat dibandingkan implementasi referensi ASCON.
\end{itemize}

Perbedaan performa yang signifikan ini dapat diatribusikan pada dua faktor utama. Pertama, pustaka \texttt{pycryptodome} untuk AES menggunakan akselerasi perangkat keras AES-NI (Intel/AMD) dan fungsi dasar yang ditulis dalam bahasa C teroptimasi. Sebaliknya, implementasi ASCON yang digunakan adalah versi referensi murni Python, yang tidak memanfaatkan fitur instruksi khusus prosesor. Namun, seperti yang akan dibahas pada bagian Analisis Model Biaya, gap kinerja ini akan menyempit secara drastis pada mikrokontroler tanpa akselerasi keras.

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.45\textwidth]{timing_comparison.png}}
\caption{Perbandingan Waktu Eksekusi pada Payload 64 Byte}
\label{fig:latency}
\end{figure}

\subsection{Analisis Penggunaan Memori}
Metrik penggunaan memori sangat kritikal untuk perangkat IoT \textit{low-end}. Pengukuran dilakukan menggunakan modul \texttt{tracemalloc} untuk menangkap \textit{peak memory usage} selama operasi kriptografi berlangsung.

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.45\textwidth]{memory_comparison.png}}
\caption{Perbandingan Penggunaan Memori Puncak}
\label{fig:memory}
\end{figure}

Seperti ditunjukkan pada Gambar \ref{fig:memory}, ASCON-128 menunjukkan superioritas efisiensi memori yang konsisten:
\begin{itemize}
    \item \textbf{ASCON-128}: Mengonsumsi rata-rata \textbf{1.40 KB} memori puncak. Konsumsi memori ini stabil dan tidak berfluktuasi secara signifikan terhadap ukuran input, berkat desain \textit{sponge construction} yang beroperasi langsung pada state internal 320-bit tanpa memerlukan buffer besar atau tabel look-up.
    \item \textbf{AES-128-GCM}: Membutuhkan rata-rata \textbf{4.88 KB}, sekitar 3.5 kali lipat lebih besar dari ASCON. Overhead memori ini berasal dari kebutuhan penyimpanan \textit{S-Box}, \textit{round keys} (key expansion), dan tabel pre-komputasi untuk fungsi perkalian medan Galois (GHASH) pada mode GCM.
\end{itemize}

Hasil ini menegaskan bahwa untuk perangkat dengan SRAM sangat terbatas (misalnya $< 4$ KB), ASCON adalah pilihan yang jauh lebih layak dibandingkan AES-GCM.

\subsection{Dampak Ukuran Payload terhadap Kinerja}
Selain pengujian pada 64 byte, analisis lebih lanjut dilakukan pada variasi ukuran payload (8, 16, 32 Byte) untuk memahami perilaku skalabilitas algoritma. Data hasil pengujian dirangkum dalam Tabel \ref{tab:payload_metrics}.

\begin{table}[htbp]
\caption{Metrik Kinerja Berdasarkan Ukuran Payload}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Payload} & \multicolumn{2}{|c|}{\textbf{Waktu Enkripsi ($\mu$s)}} & \multicolumn{2}{|c|}{\textbf{Rasio Kecepatan}} \\
\cline{2-5} 
\textbf{(Bytes)} & \textbf{ASCON} & \textbf{AES-GCM} & \textbf{AES vs ASCON} \\
\hline
8 & 197.99 & 38.20 & 5.2x \\
\hline
16 & 217.83 & 37.69 & 5.8x \\
\hline
32 & 265.16 & 38.05 & 7.0x \\
\hline
64 & 350.75 & 38.48 & 9.1x \\
\hline
\end{tabular}
\label{tab:payload_metrics}
\end{center}
\end{table}

Temuan menarik dari Tabel \ref{tab:payload_metrics} adalah perilaku penskalaan kinerja:
\begin{enumerate}
    \item \textbf{AES-128-GCM Constant Time}: Waktu eksekusi AES hampir konstan ($\approx 38 \mu$s) terlepas dari ukuran payload kecil. Hal ini menunjukkan bahwa biaya komputasi AES didominasi oleh \textit{fixed overhead} (inisialisasi cipher, inisialisasi GHASH, finalisasi tag), sementara biaya enkripsi per-bloknya sangat kecil berkat akselerasi hardware.
    \item \textbf{ASCON Linear Scaling}: Kinerja ASCON menurun secara linear seiring bertambahnya ukuran data. Ini wajar karena struktur sponge memproses data blok demi blok secara serial.
    \item \textbf{Efisiensi Relatif pada Payload Kecil}: Pada payload 8 byte, ASCON "hanya" 5.2x lebih lambat dari AES, dibandingkan 9.1x pada 64 byte. Ini menunjukkan bahwa untuk pesan-pesan sangat pendek (seperti token \textit{unlock} atau status sensor sederhana), inefisiensi relatif ASCON berkurang.
\end{enumerate}

Gambar \ref{fig:payload_analysis} memvisualisasikan tren ini, di mana kurva AES terlihat datar sementara ASCON menanjak.

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.45\textwidth]{payload_size_analysis.png}}
\caption{Analisis Komprehensif Dampak Ukuran Payload}
\label{fig:payload_analysis}
\end{figure}

\subsection{Analisis Model Biaya Komputasi}
Untuk memahami implikasi hasil ini pada perangkat keras mikrokontroler sebenarnya (di mana Python tidak digunakan), kita dapat memodelkan total waktu eksekusi ($T$) sebagai fungsi dari \textit{fixed overhead} ($C_{fixed}$) dan biaya per-byte ($C_{byte}$):
\begin{equation}
T(n) = C_{fixed} + (n \times C_{byte})
\end{equation}
Dimana $n$ adalah jumlah blok atau byte data.

\subsubsection{Kasus AES-GCM}
AES-GCM memiliki $C_{fixed}$ yang tinggi karena kompleksitas inisialisasi GHASH dan Key Schedule. Namun, $C_{byte}$ sangat rendah di PC modern. Pada mikrokontroler tanpa instruksi khusus, $C_{byte}$ akan meningkat drastis karena operasi perkalian Galois harus dilakukan secara perangkat lunak, yang lambat dan memakan banyak siklus CPU.

\subsubsection{Kasus ASCON}
ASCON didesisain dengan $C_{fixed}$ yang moderat (inisialisasi permutasi) dan $C_{byte}$ yang juga moderat namun efisien secara software. Permutasi ASCON hanya menggunakan operasi XOR dan bit-shift yang sangat murah di semua arsitektur CPU (mulai dari 8-bit AVR hingga 32-bit ARM).
Oleh karena itu, pada lingkungan \textit{bare-metal} mikrokontroler:
\begin{itemize}
    \item Penalti kinerja ASCON tidak akan sebesar 9x lipat seperti di simulasi Python.
    \item Untuk payload sangat kecil ($<16$ byte), ASCON berpotensi memiliki kinerja yang setara atau bahkan lebih cepat dari implementasi software AES-GCM karena overhead inisialisasi yang lebih sederhana.
\end{itemize}

\subsection{Rekomendasi Implementasi Berbasis Perangkat}
Berdasarkan analisis latensi dan memori di atas, berikut adalah rekomendasi pemilihan algoritma berdasarkan kelas perangkat IoT:

\subsubsection{Sangat Terkendala (Contoh: Arduino Uno, ATTiny)}
\textbf{Rekomendasi: ASCON-128}.
Dengan RAM hanya 2KB, AES-GCM yang membutuhkan hampir 4.9KB memori kerja tidak mungkin diimplementasikan secara aman tanpa optimasi ekstrem yang mengorbankan keamanan (misalnya membuang pre-computed tables). ASCON dengan footprint 1.4KB dapat berjalan dengan nyaman, menyisakan ruang untuk logika aplikasi utama.

\subsubsection{Terkendala Moderat (Contoh: ARM Cortex-M0/M3)}
\textbf{Rekomendasi: ASCON-128}.
Meskipun perangkat ini memiliki RAM 16-32KB, penggunaan ASCON memberikan efisiensi daya yang lebih baik dan membebaskan memori untuk fitur lain (seperti stack Bluetooth atau RTOS). Kinerja throughput ASCON (> 2800 ops/sec) sudah jauh melampaui kebutuhan operasional kunci sepeda.

\subsubsection{Kinerja Tinggi/Gateway (Contoh: ESP32, Raspberry Pi)}
\textbf{Rekomendasi: AES-128-GCM}.
Perangkat seperti ESP32 seringkali memiliki blok akselerator kriptografi perangkat keras (\textit{hardware crypto engine}). Dalam kasus ini, AES akan berjalan 10-100x lebih cepat daripada implementasi perangkat lunak manapun dengan konsumsi daya minimal. Kompatibilitas dengan standar industri yang luas juga menjadi nilai tambah.

\subsection{Analisis Keamanan}
Kedua algoritma, ASCON dan AES-GCM, menyediakan properti keamanan \textit{Authenticated Encryption} (AE) yang menjamin kerahasiaan dan integritas data secara simultan.

\subsubsection{Integritas dan Autentikasi}
Dalam simulasi serangan manipulasi ciphertext, kedua algoritma berhasil mendeteksi perubahan sekecil satu bit pun. Tag autentikasi (MAC) yang dihasilkan akan berbeda saat didekripsi, memicu pengecualian (\textit{exception}) dan mencegah sistem memproses data yang korup atau berbahaya.

\subsubsection{Resistensi Side-Channel}
Secara teoritis, desain ASCON lebih ramah terhadap implementasi yang resisten terhadap serangan kanal samping (\textit{side-channel attacks}) seperti \textit{timing analysis}. Operasi bitwise ASCON secara alami cenderung \textit{constant-time} pada banyak arsitektur. Sebaliknya, implementasi AES yang naif (menggunakan tabel look-up untuk S-Box) sangat rentan terhadap serangan \textit{cache-timing}, kecuali diimplementasikan dengan teknik \textit{bitslicing} yang kompleks.

\subsection{Throughput}
Meskipun bukan fokus utama untuk aplikasi kunci sepeda, throughput diukur untuk kelengkapan data (Gambar \ref{fig:throughput}).
\begin{figure}[htbp]
\centerline{\includegraphics[width=0.45\textwidth]{throughput_comparison.png}}
\caption{Perbandingan Throughput Operasi Enkripsi}
\label{fig:throughput}
\end{figure}
ASCON memberikan throughput sekitar 2 - 5 MB/s (dalam implementasi Python terpusat pada operasi). Untuk mikrokontroler yang berjalan pada \textit{clock} puluhan MHz, ini menerjemahkan menjadi kemampuan memproses paket kontrol dalam hitungan milidetik, yang tidak akan dirasakan penundaannya oleh pengguna akhir (\textit{imperceptible latency}).


